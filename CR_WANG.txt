      Compte-rendu TP3 AspectJ  Lingxiao WANG                Synchronized-ASPECTJ  Dans cette partie on a modifie les méthodes •débit, crédit & transfert• pour quelles tiennent compte des concurrences entre les threads de crédit et transfert qu'on les a ajoute dans la classe • SimpleAccountTest •  public class SimpleAccountTest {   public static void main(String[] args)  throws AccountException  {  SimpleAccountImpl account1, account2;  int accountNb1 = 1, accountNb2 = 2; account1 = new SimpleAccountImpl(accountNb1, 500);  account2 = new SimpleAccountImpl(accountNb2, 100);   System. out  .println("\nSimpleAccountTest.main: Initially, account1.balance="  + account1.getBalance()  + ", account2.balance="  + account2.getBalance());   Thread th1 = new Thread(new ThTransfer(account1,account2));  Thread th2 = new Thread(new ThTransfer(account1,account2));  Thread th3 = new Thread(new ThTransfer(account1,account2));  Thread th4 = new Thread(new ThTransfer(account1,account2));  Thread th5 = new Thread(new ThTransfer(account1,account2));   Thread th6 = new Thread(new ThCredit(account1));  Thread th7 = new Thread(new ThCredit(account1));  Thread th8 = new Thread(new ThCredit(account1));  Thread th9 = new Thread(new ThCredit(account1));  Thread th10 = new Thread(new ThCredit(account1));   th1.start();  th2.start();  th3.start();  th4.start();  th5.start();  th6.start();  th7.start();  th8.start();  th9.start();  th10.start() } }   D’ici, on ajoute 5 threads (Thread th1- Thread th5) pour le crédit ( chaque crédit 100euro chaque 10 ms le account 1), et les autre threads pour le transfert de 100 euro chaque 10 ms de account 1 vers account 2.  A l'initialisation Account 1 = 500 euro, Account 2 = 100 euro.  Ensuit on définit un aspect (LogAspect) qui a 3 pointcut (debitSynchro, creditSynchro, transferSynchro) :   pointcut debitSynchro():execution(* *.SimpleAccountImpl.debit(..)); pointcut creditSynchro():execution(* *.SimpleAccountImpl.credit(..)); pointcut transferSynchro():execution(* *.InterAccountOperations.transfer(..));   Une fois qu'un thread veut débiter un compte, l'aspectJ commence la synchronisation entre la threads en verrouiller la section critique par synchronized(this).     void around (float amount):debitSynchro()&&args(amount){ synchronized(this){ proceed(amount); } }  void around (float amount):creditSynchro()&&args(amount){ synchronized(this){ proceed(amount); } }  void around (Account from, Account to, float amount): transferSynchro ()&& args (from, to, amount){ synchronized(this){ proceed( from, to, amount); }    On exécute ce programme, le résultat comme suivant:    SimpleAccountTest.main: Initially, account1.balance=500.0, account2.balance=100.0 -------------------------------------------- Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-0,5,main]--debit 100.0 from Account 1, et account1 solde 400.0 Thread[Thread-0,5,main]--credit 100.0 to Account 2, et solde 200.0 Transfert finit !!!!!!!!!!!!!!!!!!! --------------------------------------------  -------------------------------------------- Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-1,5,main]--debit 100.0 from Account 1, et account1 solde 300.0 Thread[Thread-1,5,main]--credit 100.0 to Account 2, et solde 300.0 Transfert finit !!!!!!!!!!!!!!!!!!! --------------------------------------------  -------------------------------------------- Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-2,5,main]--debit 100.0 from Account 1, et account1 solde 200.0 Thread[Thread-2,5,main]--credit 100.0 to Account 2, et solde 400.0 Transfert finit !!!!!!!!!!!!!!!!!!! --------------------------------------------  -------------------------------------------- Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-3,5,main]--debit 100.0 from Account 1, et account1 solde 100.0 Thread[Thread-3,5,main]--credit 100.0 to Account 2, et solde 500.0 Transfert finit !!!!!!!!!!!!!!!!!!! --------------------------------------------  -------------------------------------------- Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-4,5,main]--debit 100.0 from Account 1, et account1 solde 0.0 Thread[Thread-4,5,main]--credit 100.0 to Account 2, et solde 600.0 Transfert finit !!!!!!!!!!!!!!!!!!! --------------------------------------------        Maintenant, le compte 1 est vide, donc la transaction termine. Attend 3s, Les autre threads alimentent le compte 1.     -------------------------------------------- Thread[Thread-5,5,main]--credit 100.0 to Account 1, et solde 100.0 -------------------------------------------- Thread[Thread-6,5,main]--credit 100.0 to Account 1, et solde 200.0 -------------------------------------------- Thread[Thread-7,5,main]--credit 100.0 to Account 1, et solde 300.0 -------------------------------------------- Thread[Thread-8,5,main]--credit 100.0 to Account 1, et solde 400.0 -------------------------------------------- Thread[Thread-9,5,main]--credit 100.0 to Account 1, et solde 500.0 --------------------------------------------    Si la somme du compte 1 n’est pas 0, et il n’y a pas les autre threads actives, le compte 1 continue a «transfert » vers compte 2.    Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-0,5,main]--debit 100.0 from Account 1, et account1 solde 400.0 Thread[Thread-0,5,main]--credit 100.0 to Account 2, et solde 700.0 Transfert finit !!!!!!!!!!!!!!!!!!!  Transfert commence !!!!!!!!!!!!!!!!! Thread[Thread-1,5,main]--debit 100.0 from Account 1, et account1 solde 300.0 Thread[Thread-1,5,main]--credit 100.0 to Account 2, et solde 800.0 Transfert finit !!!!!!!!!!!!!!!!!!! : : :    On voit bien qu'après on ajoute la contrainte « synchronized » par l’AspectJ, on voit plus 2 débits qui entrent dans la section critiques, on remarque bien qu'une fois un débit commence il se termine bien sans être interrompu par d'autres threads contrairement au premier cas.   